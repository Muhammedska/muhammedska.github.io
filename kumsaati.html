<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Siyah Kum Saati v1.2.3</title>
    
    <!-- Google Fonts: Outfit -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;500;700&display=swap" rel="stylesheet">
    
    <script src="https://cdn.tailwindcss.com"></script>
    
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background: radial-gradient(circle at center, #e0f7fa 0%, #b2ebf2 100%);
            color: #334155; 
            font-family: 'Outfit', sans-serif; 
        }
        #canvas-container { width: 100%; height: 100vh; display: block; }
        
        /* --- MODERN UI STİLLERİ --- */
        
        .glass-panel {
            background: rgba(30, 41, 59, 0.75);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 20px 40px -5px rgba(0, 128, 128, 0.15);
            color: white;
        }

        #settings-toggle-btn {
            position: absolute; top: 30px; left: 30px; z-index: 50;
            width: 50px; height: 50px;
            border-radius: 50%;
            display: flex; align-items: center; justify-content: center;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            font-size: 1.5rem;
            color: #2dd4bf; 
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid rgba(45, 212, 191, 0.3);
            box-shadow: 0 4px 15px rgba(45, 212, 191, 0.2);
        }
        #settings-toggle-btn:hover { 
            background: #fff; 
            transform: rotate(90deg) scale(1.1); 
            color: #14b8a6;
        }

        #main-hud {
            position: absolute; top: 40px; left: 50%; transform: translateX(-50%); z-index: 40;
            text-align: center;
            pointer-events: none;
            background: rgba(30, 41, 59, 0.65);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            padding: 15px 50px;
            border-radius: 40px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.1);
        }
        #hud-timer {
            font-weight: 300;
            font-size: 4.5rem;
            letter-spacing: -2px;
            line-height: 1;
            background: linear-gradient(135deg, #ffffff 0%, #99f6e4 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }
        #hud-label {
            font-size: 0.75rem; 
            letter-spacing: 4px; 
            color: #5eead4;
            text-transform: uppercase; 
            font-weight: 700;
            margin-top: 5px;
            opacity: 0.9;
        }

        #settings-panel {
            position: absolute; top: 100px; left: 30px; width: 340px; z-index: 100;
            border-radius: 24px; padding: 30px;
            opacity: 0; transform: translateX(-20px) scale(0.95); pointer-events: none;
            transition: all 0.4s cubic-bezier(0.16, 1, 0.3, 1);
        }
        #settings-panel.active { opacity: 1; transform: translateX(0) scale(1); pointer-events: auto; }

        .input-wrapper {
            background: rgba(0,0,0,0.2);
            border-radius: 16px;
            padding: 15px;
            display: flex;
            justify-content: space-between;
            margin-bottom: 20px;
            border: 1px solid rgba(255,255,255,0.05);
        }
        .time-field { display: flex; flex-direction: column; align-items: center; width: 30%; position: relative; }
        .time-field label { 
            font-size: 0.65rem; color: #ccfbf1; margin-bottom: 6px; 
            font-weight: 600; letter-spacing: 1px; 
        }
        .time-field input {
            width: 100%; background: transparent; border: none; color: white;
            text-align: center; font-size: 1.5rem; font-weight: 400;
            border-bottom: 2px solid rgba(255,255,255,0.1);
            padding-bottom: 5px;
            transition: border-color 0.3s;
            font-family: 'Outfit', sans-serif;
        }
        .time-field input:focus { outline: none; border-color: #2dd4bf; }
        .time-field input::-webkit-outer-spin-button,
        .time-field input::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }

        .btn-group { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-top: 25px; }
        .action-btn {
            padding: 14px; border-radius: 14px; font-weight: 600; cursor: pointer;
            transition: all 0.3s ease; border: none; font-size: 0.9rem;
            display: flex; align-items: center; justify-content: center; gap: 8px;
        }
        .btn-start { 
            background: #2dd4bf; color: #0f172a; 
            box-shadow: 0 4px 15px rgba(45, 212, 191, 0.3);
        }
        .btn-start:hover { transform: translateY(-2px); background: #14b8a6; box-shadow: 0 8px 20px rgba(45, 212, 191, 0.4); }
        .btn-reset { 
            background: rgba(255,255,255,0.1); color: #ccfbf1; 
            border: 1px solid rgba(255,255,255,0.1);
        }
        .btn-reset:hover { background: rgba(255,255,255,0.2); color: white; }

        .info-box { text-align: center; margin-bottom: 5px; }
        .info-value { font-size: 1.8rem; font-weight: 700; color: #2dd4bf; }
        .info-label { font-size: 0.75rem; color: #99f6e4; margin-top: -5px; }

        .close-icon {
            position: absolute; top: 20px; right: 20px; 
            width: 24px; height: 24px; opacity: 0.5; cursor: pointer; transition: opacity 0.2s;
        }
        .close-icon:hover { opacity: 1; }

        ::-webkit-scrollbar { display: none; }
    </style>
</head>
<body>

    <div id="settings-toggle-btn" onclick="togglePanel()">
        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" class="w-6 h-6">
            <path stroke-linecap="round" stroke-linejoin="round" d="M12 6v6h4.5m4.5 0a9 9 0 11-18 0 9 9 0 0118 0z" />
        </svg>
    </div>

    <div id="main-hud">
        <div id="hud-timer">00:00:00</div>
        <div id="hud-label">SAYAÇ</div>
    </div>

    <div id="settings-panel" class="glass-panel">
        <div class="flex justify-between items-center mb-6">
            <h2 class="text-xl font-semibold text-white flex items-center gap-2">
                Zamanlayıcı
            </h2>
            <div class="close-icon" onclick="togglePanel()">
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" />
                </svg>
            </div>
        </div>

        <div class="info-box">
            <div id="totalBallDisplay" class="info-value">60</div>
            <div class="info-label">Toplam Parçacık</div>
        </div>

        <div class="input-wrapper">
            <div class="time-field">
                <input type="number" id="inputH" min="0" max="24" value="0" onchange="onInputChange()" oninput="onInputChange()">
                <label>SAAT</label>
            </div>
            <div class="time-field">
                <input type="number" id="inputM" min="0" max="59" value="1" onchange="onInputChange()" oninput="onInputChange()">
                <label>DAKİKA</label>
            </div>
            <div class="time-field">
                <input type="number" id="inputS" min="0" max="59" value="0" onchange="onInputChange()" oninput="onInputChange()">
                <label>SANİYE</label>
            </div>
        </div>

        <div class="text-center text-[10px] text-teal-200 mb-2 font-medium tracking-wide opacity-60">
            DİNAMİK FİZİK MOTORU V1.2.3
        </div>

        <div class="btn-group">
            <button id="resetBtn" class="action-btn btn-reset">Sıfırla</button>
            <button id="startBtn" class="action-btn btn-start">Başlat</button>
        </div>
    </div>

    <div id="canvas-container"></div>

    <!-- Scripts -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        // --- UI MANTIĞI ---
        const panel = document.getElementById('settings-panel');
        const inputH = document.getElementById('inputH');
        const inputM = document.getElementById('inputM');
        const inputS = document.getElementById('inputS');
        const totalBallDisplay = document.getElementById('totalBallDisplay');
        const hudTimer = document.getElementById('hud-timer');
        const hudLabel = document.getElementById('hud-label');
        let isPanelOpen = false;

        function togglePanel() {
            isPanelOpen = !isPanelOpen;
            panel.classList.toggle('active', isPanelOpen);
        }

        // Kullanıcı giriş yaptığında tetiklenen ana fonksiyon
        function onInputChange() {
            const total = calculateTotalBalls();
            // Eğer sayaç çalışmıyorsa, değişiklikleri anında uygula (resetle)
            if (!isRunning) {
                resetTimerLogic();
            }
        }

        function calculateTotalBalls() {
            let h = Math.max(0, parseInt(inputH.value) || 0);
            let m = Math.max(0, parseInt(inputM.value) || 0);
            let s = Math.max(0, parseInt(inputS.value) || 0);
            
            // Görsel limitler
            if (m > 59) m = 59; 
            if (s > 59) s = 59;
            
            // Değerleri geri yazma (opsiyonel, oninput için can sıkıcı olabilir)
            // Sadece sınırları aşarsa düzeltelim, aksi halde kullanıcı yazarken silmeyelim
            if(parseInt(inputM.value) > 59) inputM.value = 59;
            if(parseInt(inputS.value) > 59) inputS.value = 59;

            const total = (h * 3600) + (m * 60) + s;
            totalBallDisplay.innerText = total;
            return total;
        }

        function updateTimerHUD(seconds) {
            const h = Math.floor(seconds / 3600);
            const m = Math.floor((seconds % 3600) / 60);
            const s = Math.floor(seconds % 60);
            const pad = (num) => num.toString().padStart(2, '0');
            hudTimer.innerText = `${pad(h)}:${pad(m)}:${pad(s)}`;
        }

        // --- THREE.JS KURULUM ---
        let scene, camera, renderer, controls;
        let hourglassGroup;
        const dummy = new THREE.Object3D();
        
        // --- FİZİK DEĞİŞKENLERİ ---
        let ballRadius = 0.15; // Dinamik değişir
        const GRAVITY_Y = -0.015; 
        const FRICTION = 0.98;    
        const SUB_STEPS = 8;      
        
        let topBallsMesh, bottomBallsMesh;
        let topPositions = [];
        let simBalls = []; let activeBalls = []; 
        let settledBalls = []; 
        
        let totalTime = 60;
        let currentTime = 60;
        let ballsFallen = 0;
        let isRunning = false;
        let lastTime = 0;

        const startBtn = document.getElementById('startBtn');
        const resetBtn = document.getElementById('resetBtn');

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xe0f7fa); 
            scene.fog = new THREE.Fog(0xe0f7fa, 15, 50);

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 3, 16); 

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.1;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            const hemiLight = new THREE.HemisphereLight(0xffffff, 0xb2ebf2, 0.7);
            scene.add(hemiLight);
            
            const dirLight = new THREE.DirectionalLight(0xfffaf0, 0.8);
            dirLight.position.set(5, 10, 5);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.set(2048, 2048);
            dirLight.shadow.bias = -0.0001;
            dirLight.shadow.radius = 4;
            scene.add(dirLight);
            
            const pointLight = new THREE.PointLight(0xfecdd3, 0.5, 20);
            pointLight.position.set(-5, 3, 5);
            scene.add(pointLight);

            createHourglassStructure();
            
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.enableRotate = false;
            controls.enableZoom = false;
            controls.enablePan = false;

            const planeGeo = new THREE.PlaneGeometry(100, 100);
            const planeMat = new THREE.ShadowMaterial({ opacity: 0.05 }); 
            const plane = new THREE.Mesh(planeGeo, planeMat);
            plane.rotation.x = -Math.PI / 2;
            plane.position.y = -5.1;
            plane.receiveShadow = true;
            scene.add(plane);

            window.addEventListener('resize', onWindowResize);
            
            // Başlangıç ayarları
            calculateTotalBalls();
            resetTimerLogic();
        }

        function createHourglassStructure() {
            hourglassGroup = new THREE.Group();
            
            const glassMat = new THREE.MeshPhysicalMaterial({
                color: 0xa5f3fc, metalness: 0.1, roughness: 0.2, transmission: 0.4, 
                thickness: 1.5, clearcoat: 1.0, clearcoatRoughness: 0.1,
                transparent: true, opacity: 0.6, side: THREE.DoubleSide
            });
            const frameMat = new THREE.MeshStandardMaterial({ color: 0x94a3b8, roughness: 0.4, metalness: 0.5 });

            const glassPoints = [];
            glassPoints.push(new THREE.Vector2(2.5, 5));
            glassPoints.push(new THREE.Vector2(2.5, 4.8));
            for(let i=0; i<=10; i++) {
                let t = i/10;
                let x = 0.2 + (2.3 * t * t);
                let y = 0 + (4.8 * t);
                glassPoints.push(new THREE.Vector2(x, y));
            }
            glassPoints.push(new THREE.Vector2(0.2, 0));
            for(let i=0; i<=10; i++) {
                let t = i/10;
                let x = 0.2 + (2.3 * t * t);
                let y = 0 - (4.8 * t);
                glassPoints.push(new THREE.Vector2(x, y));
            }
            glassPoints.push(new THREE.Vector2(2.5, -4.8));
            glassPoints.push(new THREE.Vector2(2.5, -5));

            const glass = new THREE.Mesh(new THREE.LatheGeometry(glassPoints, 64), glassMat);
            glass.receiveShadow = true;
            hourglassGroup.add(glass);

            const topBase = new THREE.Mesh(new THREE.CylinderGeometry(3, 3, 0.5, 64), frameMat);
            topBase.position.y = 5.25; topBase.castShadow = true; topBase.receiveShadow = true;
            hourglassGroup.add(topBase);

            const bottomBase = new THREE.Mesh(new THREE.CylinderGeometry(3, 3, 0.5, 64), frameMat);
            bottomBase.position.y = -5.25; bottomBase.castShadow = true; bottomBase.receiveShadow = true;
            hourglassGroup.add(bottomBase);

            const rodGeo = new THREE.CylinderGeometry(0.12, 0.12, 10.5);
            for (let i = 0; i < 3; i++) {
                const rod = new THREE.Mesh(rodGeo, frameMat);
                const angle = (i / 3) * Math.PI * 2;
                rod.position.set(Math.cos(angle) * 2.8, 0, Math.sin(angle) * 2.8);
                rod.castShadow = true;
                hourglassGroup.add(rod);
            }
            scene.add(hourglassGroup);
        }

        function getGlassRadiusAtY(y) {
            const absY = Math.abs(y);
            if (absY >= 4.8) return 2.5;
            const t = absY / 4.8;
            return Math.max(0.15, 0.2 + (2.3 * t * t)); 
        }

        function calculateTopPositions(count) {
            const positions = [];
            let currentCount = 0;
            let layerY = 0.5;
            const layerStep = ballRadius * 1.732;
            
            while(currentCount < count && layerY < 5.0) {
                const glassR = getGlassRadiusAtY(layerY);
                const availableR = glassR - ballRadius - 0.05;
                if (availableR >= 0) {
                    if (currentCount < count) {
                        positions.push({x:0, y:layerY, z:0});
                        currentCount++;
                    }
                    let ringRadius = ballRadius * 2.05;
                    while (ringRadius <= availableR && currentCount < count) {
                        const circum = 2 * Math.PI * ringRadius;
                        const ballsInRing = Math.floor(circum / (ballRadius * 2.05));
                        for (let i = 0; i < ballsInRing && currentCount < count; i++) {
                            const angle = (i / ballsInRing) * Math.PI * 2;
                            const offset = (Math.random() - 0.5) * 0.02;
                            positions.push({
                                x: Math.cos(angle + offset) * ringRadius,
                                y: layerY,
                                z: Math.sin(angle + offset) * ringRadius
                            });
                            currentCount++;
                        }
                        ringRadius += ballRadius * 2.05;
                    }
                }
                layerY += layerStep;
            }
            return positions;
        }

        function initializeBalls(count) {
            if (topBallsMesh) { hourglassGroup.remove(topBallsMesh); topBallsMesh.dispose(); }
            if (bottomBallsMesh) { hourglassGroup.remove(bottomBallsMesh); bottomBallsMesh.dispose(); }
            simBalls = []; activeBalls = []; settledBalls = [];
            
            topPositions = calculateTopPositions(count);
            
            const ballGeo = new THREE.SphereGeometry(ballRadius, 12, 12);
            // Siyah/Metalik Materyal
            const ballMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.2, metalness: 0.6 });
            
            topBallsMesh = new THREE.InstancedMesh(ballGeo, ballMat, count);
            topBallsMesh.castShadow = true; topBallsMesh.frustumCulled = false;
            
            bottomBallsMesh = new THREE.InstancedMesh(ballGeo, ballMat, count);
            bottomBallsMesh.castShadow = true; bottomBallsMesh.frustumCulled = false;
            bottomBallsMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);

            for (let i = 0; i < count; i++) {
                if (i < topPositions.length) {
                    dummy.position.set(topPositions[i].x, topPositions[i].y, topPositions[i].z);
                    dummy.scale.set(1, 1, 1);
                } else { dummy.scale.set(0,0,0); }
                dummy.updateMatrix();
                topBallsMesh.setMatrixAt(i, dummy.matrix);
                
                dummy.scale.set(0, 0, 0);
                dummy.updateMatrix();
                bottomBallsMesh.setMatrixAt(i, dummy.matrix);
                
                simBalls.push({
                    x: 0, y: -10, z: 0, oldX: 0, oldY: -10, oldZ: 0,
                    active: false, meshIndex: i
                });
            }
            topBallsMesh.instanceMatrix.needsUpdate = true;
            bottomBallsMesh.instanceMatrix.needsUpdate = true;
            hourglassGroup.add(topBallsMesh);
            hourglassGroup.add(bottomBallsMesh);
            ballsFallen = 0;
        }

        function updatePhysics() {
            for (let step = 0; step < SUB_STEPS; step++) {
                for (let i = 0; i < activeBalls.length; i++) {
                    const id = activeBalls[i];
                    const b = simBalls[id];
                    const vx = (b.x - b.oldX) * FRICTION;
                    const vy = (b.y - b.oldY) * FRICTION;
                    const vz = (b.z - b.oldZ) * FRICTION;
                    b.oldX = b.x; b.oldY = b.y; b.oldZ = b.z;
                    b.x += vx; b.y += vy + GRAVITY_Y / SUB_STEPS; b.z += vz;
                }
                solveConstraints();
                solveCollisions();
            }
            for (let i = 0; i < activeBalls.length; i++) {
                const id = activeBalls[i];
                const b = simBalls[id];
                dummy.position.set(b.x, b.y, b.z);
                dummy.scale.set(1, 1, 1);
                dummy.updateMatrix();
                bottomBallsMesh.setMatrixAt(id, dummy.matrix);
            }
            bottomBallsMesh.instanceMatrix.needsUpdate = true;
        }

        function solveConstraints() {
            for (let i = 0; i < activeBalls.length; i++) {
                const id = activeBalls[i];
                const b = simBalls[id];
                
                const glassR = getGlassRadiusAtY(b.y);
                const maxR = glassR - ballRadius;
                const distSq = b.x*b.x + b.z*b.z;
                
                if (distSq > maxR * maxR) {
                    const dist = Math.sqrt(distSq);
                    const ratio = maxR / dist;
                    b.x *= ratio; b.z *= ratio;
                    b.oldY = b.y - (b.y - b.oldY) * 0.95; 
                }
                if (Math.abs(b.y) < 0.5) {
                    const speedSq = (b.x - b.oldX)**2 + (b.y - b.oldY)**2 + (b.z - b.oldZ)**2;
                    if (speedSq < 0.000001) {
                        b.x += (Math.random() - 0.5) * 0.002;
                        b.z += (Math.random() - 0.5) * 0.002;
                    }
                }
                if (b.y < -4.8 + ballRadius) {
                    b.y = -4.8 + ballRadius;
                    const vx = b.x - b.oldX;
                    const vz = b.z - b.oldZ;
                    b.oldX = b.x - vx * 0.9;
                    b.oldZ = b.z - vz * 0.9;
                }
            }
        }

        function solveCollisions() {
            const minDist = ballRadius * 2;
            const minDistSq = minDist * minDist;
            const count = activeBalls.length;
            for (let i = 0; i < count; i++) {
                const idA = activeBalls[i];
                const bA = simBalls[idA];
                for (let j = i + 1; j < count; j++) {
                    const idB = activeBalls[j];
                    const bB = simBalls[idB];
                    if (Math.abs(bA.y - bB.y) >= minDist) continue;
                    const dx = bA.x - bB.x; const dy = bA.y - bB.y; const dz = bA.z - bB.z;
                    const distSq = dx*dx + dy*dy + dz*dz;
                    if (distSq < minDistSq && distSq > 0.00001) {
                        const dist = Math.sqrt(distSq);
                        const overlap = (minDist - dist) * 0.5;
                        const nx = dx / dist; const ny = dy / dist; const nz = dz / dist;
                        bA.x += nx * overlap; bA.y += ny * overlap; bA.z += nz * overlap;
                        bB.x -= nx * overlap; bB.y -= ny * overlap; bB.z -= nz * overlap;
                    }
                }
            }
        }

        function spawnBall() {
            if (ballsFallen >= totalTime || ballsFallen >= topPositions.length) return;
            const index = ballsFallen;
            const startPos = topPositions[index];
            dummy.position.set(startPos.x, startPos.y, startPos.z);
            dummy.scale.set(0, 0, 0);
            dummy.updateMatrix();
            topBallsMesh.setMatrixAt(index, dummy.matrix);
            topBallsMesh.instanceMatrix.needsUpdate = true;
            
            const ball = simBalls[index];
            ball.x = startPos.x; ball.y = startPos.y; ball.z = startPos.z;
            ball.oldX = startPos.x; ball.oldY = startPos.y; ball.oldZ = startPos.z;
            ball.active = true;
            activeBalls.push(index);
            ballsFallen++;
        }

        function animate() {
            requestAnimationFrame(animate);
            if (activeBalls.length > 0) updatePhysics();
            if (isRunning) {
                const now = performance.now();
                if (now - lastTime >= 1000) {
                    lastTime = now;
                    tick();
                }
            }
            controls.update();
            renderer.render(scene, camera);
        }
        
        function tick() {
            if (currentTime > 0) {
                currentTime--;
                updateTimerHUD(currentTime);
                spawnBall();
            } else {
                stopTimer();
            }
        }

        function startTimer() {
            if (!isRunning) {
                if (currentTime <= 0) resetTimerLogic();
                isRunning = true;
                hudLabel.innerText = "SAYILIYOR";
                hudLabel.style.color = "#2dd4bf"; 
                togglePanel(); if(isPanelOpen) togglePanel();
                lastTime = performance.now();
            } else {
                isRunning = false;
                hudLabel.innerText = "DURAKLATILDI";
                hudLabel.style.color = "#fcd34d"; 
            }
        }

        function stopTimer() {
            isRunning = false;
            hudLabel.innerText = "TAMAMLANDI";
            hudLabel.style.color = "#f87171"; 
        }

        function resetTimerLogic() {
            const total = calculateTotalBalls();
            totalTime = total > 0 ? total : 60;
            
            // --- DİNAMİK YARIÇAP HESABI ---
            // 60 saniye için r=0.15 baz alındı
            const baseCount = 60;
            if (total > baseCount) {
                ballRadius = 0.15 * Math.pow(baseCount / total, 1/3);
            } else {
                ballRadius = 0.15;
            }
            ballRadius = Math.max(0.04, Math.min(0.2, ballRadius));
            
            currentTime = totalTime;
            isRunning = false;
            initializeBalls(totalTime);
            updateTimerHUD(currentTime);
            hudLabel.innerText = "HAZIR";
            hudLabel.style.color = "#0f766e"; 
            
            hourglassGroup.rotation.z = Math.PI;
            let rotationProgress = 0;
            const rotateInterval = setInterval(() => {
                rotationProgress += 0.1;
                hourglassGroup.rotation.z -= 0.1;
                if (hourglassGroup.rotation.z <= 0) {
                    hourglassGroup.rotation.z = 0;
                    clearInterval(rotateInterval);
                }
            }, 16);
        }

        startBtn.addEventListener('click', startTimer);
        resetBtn.addEventListener('click', resetTimerLogic);
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>
</body>
</html>

