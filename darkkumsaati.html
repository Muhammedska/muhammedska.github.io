<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Siyah Sıvı Saati - Liquid Form</title>

    <!-- Google Fonts: Outfit -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;500;700&display=swap" rel="stylesheet">

    <script src="https://cdn.tailwindcss.com"></script>

    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background: radial-gradient(circle at center, #0f172a 0%, #020617 100%); /* Daha karanlık, modern arka plan */
            color: #e2e8f0; 
            font-family: 'Outfit', sans-serif; 
        }
        #canvas-container { width: 100%; height: 100vh; display: block; }

        /* --- MODERN UI STİLLERİ --- */

        .glass-panel {
            background: rgba(15, 23, 42, 0.85);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.08);
            box-shadow: 0 20px 40px -5px rgba(0, 0, 0, 0.5);
            color: white;
        }

        #settings-toggle-btn {
            position: absolute; top: 30px; left: 30px; z-index: 50;
            width: 50px; height: 50px;
            border-radius: 50%;
            display: flex; align-items: center; justify-content: center;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            font-size: 1.5rem;
            color: #38bdf8; 
            background: rgba(30, 41, 59, 0.9);
            border: 1px solid rgba(56, 189, 248, 0.3);
            box-shadow: 0 4px 15px rgba(56, 189, 248, 0.2);
        }
        #settings-toggle-btn:hover { 
            background: #38bdf8; 
            transform: rotate(90deg) scale(1.1); 
            color: #0f172a;
        }

        #main-hud {
            position: absolute; top: 40px; left: 50%; transform: translateX(-50%); z-index: 40;
            text-align: center;
            pointer-events: none;
            background: rgba(15, 23, 42, 0.75);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            padding: 15px 50px;
            border-radius: 40px;
            border: 1px solid rgba(255, 255, 255, 0.05);
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.3);
        }
        #hud-timer {
            font-weight: 300;
            font-size: 4.5rem;
            letter-spacing: -2px;
            line-height: 1;
            background: linear-gradient(135deg, #e0f2fe 0%, #38bdf8 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }
        #hud-label {
            font-size: 0.75rem; 
            letter-spacing: 4px; 
            color: #7dd3fc;
            text-transform: uppercase; 
            font-weight: 700;
            margin-top: 5px;
            opacity: 0.9;
        }

        #settings-panel {
            position: absolute; top: 100px; left: 30px; width: 340px; z-index: 100;
            border-radius: 24px; padding: 30px;
            opacity: 0; transform: translateX(-20px) scale(0.95); pointer-events: none;
            transition: all 0.4s cubic-bezier(0.16, 1, 0.3, 1);
        }
        #settings-panel.active { opacity: 1; transform: translateX(0) scale(1); pointer-events: auto; }

        .input-wrapper {
            background: rgba(0,0,0,0.3);
            border-radius: 16px;
            padding: 15px;
            display: flex;
            justify-content: space-between;
            margin-bottom: 20px;
            border: 1px solid rgba(255,255,255,0.05);
        }
        .time-field { display: flex; flex-direction: column; align-items: center; width: 30%; position: relative; }
        .time-field label { 
            font-size: 0.65rem; color: #bae6fd; margin-bottom: 6px; 
            font-weight: 600; letter-spacing: 1px; 
        }
        .time-field input {
            width: 100%; background: transparent; border: none; color: white;
            text-align: center; font-size: 1.5rem; font-weight: 400;
            border-bottom: 2px solid rgba(255,255,255,0.1);
            padding-bottom: 5px;
            transition: border-color 0.3s;
            font-family: 'Outfit', sans-serif;
        }
        .time-field input:focus { outline: none; border-color: #38bdf8; }
        .time-field input::-webkit-outer-spin-button,
        .time-field input::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }

        .btn-group { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-top: 25px; }
        .action-btn {
            padding: 14px; border-radius: 14px; font-weight: 600; cursor: pointer;
            transition: all 0.3s ease; border: none; font-size: 0.9rem;
            display: flex; align-items: center; justify-content: center; gap: 8px;
        }
        .btn-start { 
            background: #38bdf8; color: #0f172a; 
            box-shadow: 0 4px 15px rgba(56, 189, 248, 0.3);
        }
        .btn-start:hover { transform: translateY(-2px); background: #0ea5e9; box-shadow: 0 8px 20px rgba(56, 189, 248, 0.4); }
        .btn-reset { 
            background: rgba(255,255,255,0.1); color: #bae6fd; 
            border: 1px solid rgba(255,255,255,0.1);
        }
        .btn-reset:hover { background: rgba(255,255,255,0.2); color: white; }

        .info-box { text-align: center; margin-bottom: 5px; }
        .info-value { font-size: 1.8rem; font-weight: 700; color: #38bdf8; }
        .info-label { font-size: 0.75rem; color: #bae6fd; margin-top: -5px; }

        .close-icon {
            position: absolute; top: 20px; right: 20px; 
            width: 24px; height: 24px; opacity: 0.5; cursor: pointer; transition: opacity 0.2s;
        }
        .close-icon:hover { opacity: 1; }

        #completion-modal {
            position: fixed; inset: 0; z-index: 999;
            background: rgba(2, 6, 23, 0.7);
            backdrop-filter: blur(8px);
            display: flex; align-items: center; justify-content: center;
            opacity: 0; pointer-events: none; transition: opacity 0.4s ease;
        }
        #completion-modal.visible { opacity: 1; pointer-events: auto; }

        .modal-content {
            background: rgba(30, 41, 59, 0.95);
            border: 1px solid rgba(56, 189, 248, 0.3);
            border-radius: 24px; padding: 40px; text-align: center;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
            transform: scale(0.9); transition: transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            max-width: 400px; width: 90%;
        }
        #completion-modal.visible .modal-content { transform: scale(1); }

        ::-webkit-scrollbar { display: none; }
    </style>
</head>
<body>

    <div id="settings-toggle-btn" onclick="togglePanel()">
        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" class="w-6 h-6">
            <path stroke-linecap="round" stroke-linejoin="round" d="M10.5 6h9.75M10.5 6a1.5 1.5 0 11-3 0m3 0a1.5 1.5 0 10-3 0M3.75 6H7.5m3 12h9.75m-9.75 0a1.5 1.5 0 01-3 0m3 0a1.5 1.5 0 00-3 0m-3.75 0H7.5m9-6h3.75m-3.75 0a1.5 1.5 0 01-3 0m3 0a1.5 1.5 0 00-3 0m-9.75 0h9.75" />
        </svg>
    </div>

    <div id="main-hud">
        <div id="hud-timer">00:00:00</div>
        <div id="hud-label">SIVI ZAMANLAYICI</div>
    </div>

    <div id="settings-panel" class="glass-panel">
        <div class="flex justify-between items-center mb-6">
            <h2 class="text-xl font-semibold text-white flex items-center gap-2">
                Ayarlar
            </h2>
            <div class="close-icon" onclick="togglePanel()">
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" />
                </svg>
            </div>
        </div>

        <div class="info-box">
            <div id="totalBallDisplay" class="info-value">60</div>
            <div class="info-label">Sıvı Parçacığı</div>
        </div>

        <div class="input-wrapper">
            <div class="time-field">
                <input type="number" id="inputH" min="0" max="24" value="0" onchange="onInputChange()" oninput="onInputChange()">
                <label>SAAT</label>
            </div>
            <div class="time-field">
                <input type="number" id="inputM" min="0" max="59" value="1" onchange="onInputChange()" oninput="onInputChange()">
                <label>DAKİKA</label>
            </div>
            <div class="time-field">
                <input type="number" id="inputS" min="0" max="59" value="0" onchange="onInputChange()" oninput="onInputChange()">
                <label>SANİYE</label>
            </div>
        </div>

        <div class="text-center text-[10px] text-sky-200 mb-2 font-medium tracking-wide opacity-60">
            LIQUID PHYSICS V2.0
        </div>

        <div class="btn-group">
            <button id="resetBtn" class="action-btn btn-reset">Sıfırla</button>
            <button id="startBtn" class="action-btn btn-start">Başlat</button>
        </div>
    </div>

    <div id="completion-modal">
        <div class="modal-content">
            <div class="flex justify-center mb-4 text-sky-400">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-16 h-16">
                    <path fill-rule="evenodd" d="M2.25 12c0-5.385 4.365-9.75 9.75-9.75s9.75 4.365 9.75 9.75-4.365 9.75-9.75 9.75S2.25 17.385 2.25 12zm13.36-1.814a.75.75 0 10-1.22-.872l-3.236 4.53L9.53 12.22a.75.75 0 00-1.06 1.06l2.25 2.25a.75.75 0 001.14-.094l3.75-5.25z" clip-rule="evenodd" />
                </svg>
            </div>
            <h2 class="text-3xl font-bold text-white mb-2">Süre Doldu!</h2>
            <p class="text-slate-300 mb-8">Zamanlayıcı başarıyla tamamlandı.</p>
            <button onclick="closeModal()" class="action-btn btn-start w-full">Tamam</button>
        </div>
    </div>

    <div id="canvas-container"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        // --- UI MANTIĞI ---
        const panel = document.getElementById('settings-panel');
        const modal = document.getElementById('completion-modal');
        const inputH = document.getElementById('inputH');
        const inputM = document.getElementById('inputM');
        const inputS = document.getElementById('inputS');
        const totalBallDisplay = document.getElementById('totalBallDisplay');
        const hudTimer = document.getElementById('hud-timer');
        const hudLabel = document.getElementById('hud-label');
        let isPanelOpen = false;

        function togglePanel() {
            isPanelOpen = !isPanelOpen;
            panel.classList.toggle('active', isPanelOpen);
        }

        function closeModal() {
            modal.classList.remove('visible');
        }

        function onInputChange() {
            const total = calculateTotalBalls();
            if (!isRunning) {
                resetTimerLogic();
            }
        }

        function calculateTotalBalls() {
            let h = Math.max(0, parseInt(inputH.value) || 0);
            let m = Math.max(0, parseInt(inputM.value) || 0);
            let s = Math.max(0, parseInt(inputS.value) || 0);
            if (m > 59) m = 59; 
            if (s > 59) s = 59;
            if(parseInt(inputM.value) > 59) inputM.value = 59;
            if(parseInt(inputS.value) > 59) inputS.value = 59;

            const total = (h * 3600) + (m * 60) + s;
            totalBallDisplay.innerText = total;
            return total;
        }

        function updateTimerHUD(seconds) {
            const h = Math.floor(seconds / 3600);
            const m = Math.floor((seconds % 3600) / 60);
            const s = Math.floor(seconds % 60);
            const pad = (num) => num.toString().padStart(2, '0');
            hudTimer.innerText = `${pad(h)}:${pad(m)}:${pad(s)}`;
        }

        // --- THREE.JS KURULUM ---
        let scene, camera, renderer, controls;
        let hourglassGroup;
        const dummy = new THREE.Object3D();

        let ballRadius = 0.15; 
        const GRAVITY_Y = -0.012; // Yerçekimini biraz azalttık, sıvı süzülsün
        const FRICTION = 0.96;    // Daha yüksek sürtünme = daha viskoz (kıvamlı) sıvı
        const SUB_STEPS = 5;      // Performans için adımları dengeledik

        // SIVI FİZİĞİ AYARLARI
        const COHESION_STRENGTH = 0.003; // Birbirini çekme gücü (Yüzey gerilimi)
        const INTERACTION_RADIUS_MULTIPLIER = 2.2; // Çapın kaç katı mesafeden etkileşime girsin

        let topBallsMesh, bottomBallsMesh;
        let topPositions = [];
        let simBalls = []; let activeBalls = []; 
        let totalTime = 60;
        let currentTime = 60;
        let ballsFallen = 0;
        let isRunning = false;
        let lastTime = 0;

        const startBtn = document.getElementById('startBtn');
        const resetBtn = document.getElementById('resetBtn');

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x020617); // Koyu lacivert
            scene.fog = new THREE.Fog(0x020617, 10, 40);

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 2, 14); 

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // Işıklandırma - Sıvı parlaması için
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xe0f2fe, 1);
            dirLight.position.set(5, 10, 5);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.set(2048, 2048);
            scene.add(dirLight);

            const blueLight = new THREE.PointLight(0x0ea5e9, 0.8, 20);
            blueLight.position.set(-5, 0, 5);
            scene.add(blueLight);

            createHourglassStructure();

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.enableRotate = false;
            controls.enableZoom = false;

            window.addEventListener('resize', onWindowResize);

            calculateTotalBalls();
            resetTimerLogic();
        }

        function createHourglassStructure() {
            hourglassGroup = new THREE.Group();

            // Cam Malzemesi - Daha şeffaf ve parlak
            const glassMat = new THREE.MeshPhysicalMaterial({
                color: 0xffffff, metalness: 0.1, roughness: 0.05, transmission: 0.9, 
                thickness: 2.0, clearcoat: 1.0, opacity: 0.3, transparent: true, side: THREE.DoubleSide
            });
            const frameMat = new THREE.MeshStandardMaterial({ color: 0x334155, roughness: 0.3, metalness: 0.8 });

            const glassPoints = [];
            glassPoints.push(new THREE.Vector2(2.5, 5));
            glassPoints.push(new THREE.Vector2(2.5, 4.8));
            for(let i=0; i<=15; i++) { // Daha pürüzsüz cam eğrisi
                let t = i/15;
                let x = 0.25 + (2.25 * t * t); // Boğazı biraz genişlettik (akışkanlık için)
                let y = 0 + (4.8 * t);
                glassPoints.push(new THREE.Vector2(x, y));
            }
            glassPoints.push(new THREE.Vector2(0.25, 0));
            for(let i=0; i<=15; i++) {
                let t = i/15;
                let x = 0.25 + (2.25 * t * t);
                let y = 0 - (4.8 * t);
                glassPoints.push(new THREE.Vector2(x, y));
            }
            glassPoints.push(new THREE.Vector2(2.5, -4.8));
            glassPoints.push(new THREE.Vector2(2.5, -5));

            const glass = new THREE.Mesh(new THREE.LatheGeometry(glassPoints, 64), glassMat);
            glass.receiveShadow = true;
            hourglassGroup.add(glass);

            const topBase = new THREE.Mesh(new THREE.CylinderGeometry(3.2, 3.2, 0.5, 64), frameMat);
            topBase.position.y = 5.25; topBase.castShadow = true;
            hourglassGroup.add(topBase);

            const bottomBase = new THREE.Mesh(new THREE.CylinderGeometry(3.2, 3.2, 0.5, 64), frameMat);
            bottomBase.position.y = -5.25; bottomBase.castShadow = true;
            hourglassGroup.add(bottomBase);

            scene.add(hourglassGroup);
        }

        function getGlassRadiusAtY(y) {
            const absY = Math.abs(y);
            if (absY >= 4.8) return 2.5;
            const t = absY / 4.8;
            return Math.max(0.18, 0.25 + (2.25 * t * t)); 
        }

        function calculateTopPositions(count) {
            const positions = [];
            let currentCount = 0;
            let layerY = 0.5;
            const layerStep = ballRadius * 1.6; // Daha sıkışık yerleşim

            while(currentCount < count && layerY < 5.0) {
                const glassR = getGlassRadiusAtY(layerY);
                const availableR = glassR - ballRadius - 0.1;
                
                if (availableR >= 0) {
                    if (currentCount < count) { positions.push({x:0, y:layerY, z:0}); currentCount++; }
                    
                    let ringRadius = ballRadius * 2.0;
                    while (ringRadius <= availableR && currentCount < count) {
                        const circum = 2 * Math.PI * ringRadius;
                        const ballsInRing = Math.floor(circum / (ballRadius * 2.0));
                        for (let i = 0; i < ballsInRing && currentCount < count; i++) {
                            const angle = (i / ballsInRing) * Math.PI * 2;
                            positions.push({
                                x: Math.cos(angle) * ringRadius,
                                y: layerY,
                                z: Math.sin(angle) * ringRadius
                            });
                            currentCount++;
                        }
                        ringRadius += ballRadius * 2.0;
                    }
                }
                layerY += layerStep;
            }
            return positions;
        }

        function initializeBalls(count) {
            if (topBallsMesh) { hourglassGroup.remove(topBallsMesh); topBallsMesh.dispose(); }
            if (bottomBallsMesh) { hourglassGroup.remove(bottomBallsMesh); bottomBallsMesh.dispose(); }
            simBalls = []; activeBalls = [];

            topPositions = calculateTopPositions(count);

            // SIVI GÖRÜNÜMÜ İÇİN MALZEME
            // Metalik ve parlak siyah sıvı (Ferrofluid gibi)
            const ballGeo = new THREE.SphereGeometry(ballRadius, 16, 16); // Daha detaylı
            const ballMat = new THREE.MeshPhysicalMaterial({ 
                color: 0x111111, 
                roughness: 0.1, // Islak görünüm
                metalness: 0.7, 
                clearcoat: 1.0,
                clearcoatRoughness: 0.1
            });

            topBallsMesh = new THREE.InstancedMesh(ballGeo, ballMat, count);
            bottomBallsMesh = new THREE.InstancedMesh(ballGeo, ballMat, count);
            bottomBallsMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);

            // Üstteki statik topları yerleştir
            for (let i = 0; i < count; i++) {
                if (i < topPositions.length) {
                    dummy.position.set(topPositions[i].x, topPositions[i].y, topPositions[i].z);
                    dummy.scale.set(1, 1, 1);
                } else { dummy.scale.set(0,0,0); }
                dummy.updateMatrix();
                topBallsMesh.setMatrixAt(i, dummy.matrix);

                // Alt (simülasyon) topları gizle
                dummy.scale.set(0, 0, 0);
                dummy.updateMatrix();
                bottomBallsMesh.setMatrixAt(i, dummy.matrix);

                simBalls.push({
                    x: 0, y: -10, z: 0, oldX: 0, oldY: -10, oldZ: 0,
                    vx: 0, vy: 0, vz: 0
                });
            }
            hourglassGroup.add(topBallsMesh);
            hourglassGroup.add(bottomBallsMesh);
            ballsFallen = 0;
        }

        // --- GELİŞMİŞ SIVI FİZİĞİ ---
        function updatePhysics() {
            // 1. ADIM: Verlet Entegrasyonu ve Kuvvetler
            for (let i = 0; i < activeBalls.length; i++) {
                const id = activeBalls[i];
                const b = simBalls[id];
                
                // Hız hesapla
                let vx = (b.x - b.oldX) * FRICTION;
                let vy = (b.y - b.oldY) * FRICTION;
                let vz = (b.z - b.oldZ) * FRICTION;

                // Konumu sakla
                b.oldX = b.x; b.oldY = b.y; b.oldZ = b.z;

                // Yerçekimi uygula
                b.y += GRAVITY_Y;

                // Yeni konuma taşı
                b.x += vx; b.y += vy; b.z += vz;
            }

            // 2. ADIM: Sınırlamalar (Duvarlar) ve Sıvı Etkileşimleri
            // Performans için alt adımlar
            for (let step = 0; step < SUB_STEPS; step++) {
                solveLiquidConstraints(); 
            }

            // 3. ADIM: Render Güncelleme
            for (let i = 0; i < activeBalls.length; i++) {
                const id = activeBalls[i];
                const b = simBalls[id];
                dummy.position.set(b.x, b.y, b.z);
                dummy.scale.set(1, 1, 1);
                dummy.updateMatrix();
                bottomBallsMesh.setMatrixAt(id, dummy.matrix);
            }
            bottomBallsMesh.instanceMatrix.needsUpdate = true;
        }

        function solveLiquidConstraints() {
            const count = activeBalls.length;
            const minDist = ballRadius * 2;
            const minDistSq = minDist * minDist;
            
            // Sıvı etkileşim yarıçapı (Çekim alanı)
            const interactionDist = minDist * INTERACTION_RADIUS_MULTIPLIER;
            const interactionDistSq = interactionDist * interactionDist;

            // --- PARTİKÜL-PARTİKÜL ETKİLEŞİMİ ---
            for (let i = 0; i < count; i++) {
                const idA = activeBalls[i];
                const bA = simBalls[idA];

                // --- DUVAR ETKİLEŞİMİ (Kapsayıcı) ---
                const glassR = getGlassRadiusAtY(bA.y);
                const maxR = glassR - ballRadius;
                const distFromCenterSq = bA.x*bA.x + bA.z*bA.z;

                if (distFromCenterSq > maxR * maxR) {
                    const dist = Math.sqrt(distFromCenterSq);
                    const ratio = maxR / dist;
                    bA.x *= ratio; bA.z *= ratio;
                    // Duvar sürtünmesi (yapışkanlık)
                    bA.oldY = bA.y - (bA.y - bA.oldY) * 0.9; 
                }
                
                // Zemin sınırı
                if (bA.y < -4.8 + ballRadius) {
                    bA.y = -4.8 + ballRadius;
                    const damp = 0.8; // Zemin sürtünmesi
                    bA.oldX = bA.x - (bA.x - bA.oldX) * damp;
                    bA.oldZ = bA.z - (bA.z - bA.oldZ) * damp;
                }

                // --- SIVI PARÇACIK ETKİLEŞİMLERİ ---
                // O(N^2) döngüsü - çok parçacıkta yavaşlar ama sıvı için gerekli
                // Performans için Y ekseninde uzak olanları atla
                for (let j = i + 1; j < count; j++) {
                    const idB = activeBalls[j];
                    const bB = simBalls[idB];

                    // Hızlı eleme (Y ekseni farkı çoksa bakma)
                    if (Math.abs(bA.y - bB.y) >= interactionDist) continue;

                    const dx = bA.x - bB.x;
                    const dy = bA.y - bB.y;
                    const dz = bA.z - bB.z;
                    const distSq = dx*dx + dy*dy + dz*dz;

                    // 1. BASINÇ (İtme) - Çok yakınlarsa
                    if (distSq < minDistSq && distSq > 0.00001) {
                        const dist = Math.sqrt(distSq);
                        const overlap = (minDist - dist) * 0.5; // Sert itme
                        const nx = dx / dist; const ny = dy / dist; const nz = dz / dist;
                        
                        // İtme uygula (Konum tabanlı)
                        const pushX = nx * overlap;
                        const pushY = ny * overlap;
                        const pushZ = nz * overlap;

                        bA.x += pushX; bA.y += pushY; bA.z += pushZ;
                        bB.x -= pushX; bB.y -= pushY; bB.z -= pushZ;
                    } 
                    // 2. KOHEZYON (Çekme/Yüzey Gerilimi) - Yakınlarsa ama değmiyorlarsa
                    else if (distSq < interactionDistSq) {
                        const dist = Math.sqrt(distSq);
                        // Mesafe arttıkça çekim azalır (Linear falloff)
                        const forceFactor = (1 - (dist / interactionDist)) * COHESION_STRENGTH;
                        
                        const nx = dx / dist; const ny = dy / dist; const nz = dz / dist;

                        const pullX = nx * forceFactor;
                        const pullY = ny * forceFactor;
                        const pullZ = nz * forceFactor;

                        // Eski konumu değiştirerek hızı etkile (Verlet force hack)
                        bA.oldX += pullX; bA.oldY += pullY; bA.oldZ += pullZ;
                        bB.oldX -= pullX; bB.oldY -= pullY; bB.oldZ -= pullZ;
                    }
                }
            }
        }

        function spawnBall() {
            if (ballsFallen >= totalTime || ballsFallen >= topPositions.length) return;
            const index = ballsFallen;
            const startPos = topPositions[index];
            
            // Üstteki topu yok et
            dummy.position.set(startPos.x, startPos.y, startPos.z);
            dummy.scale.set(0, 0, 0);
            dummy.updateMatrix();
            topBallsMesh.setMatrixAt(index, dummy.matrix);
            topBallsMesh.instanceMatrix.needsUpdate = true;

            // Alttaki simülasyon topunu başlat
            const ball = simBalls[index];
            ball.x = startPos.x; ball.y = startPos.y; ball.z = startPos.z;
            ball.oldX = startPos.x; ball.oldY = startPos.y; ball.oldZ = startPos.z;
            
            activeBalls.push(index);
            ballsFallen++;
        }

        function animate() {
            requestAnimationFrame(animate);
            if (activeBalls.length > 0) updatePhysics();
            if (isRunning) {
                const now = performance.now();
                if (now - lastTime >= 1000) {
                    lastTime = now;
                    tick();
                }
            }
            controls.update();
            renderer.render(scene, camera);
        }

        function tick() {
            if (currentTime > 0) {
                currentTime--;
                updateTimerHUD(currentTime);
                // Sıvı akışı daha hızlı olabilir, her saniyede birden fazla damla bırakılabilir
                // ancak senkronizasyon için şimdilik saniyede 1 bırakıyoruz
                spawnBall();
            } else {
                stopTimer();
            }
        }

        function startTimer() {
            if (!isRunning) {
                if (currentTime <= 0) resetTimerLogic();
                isRunning = true;
                hudLabel.innerText = "AKIYOR";
                hudLabel.style.color = "#38bdf8"; 
                togglePanel(); if(isPanelOpen) togglePanel();
                lastTime = performance.now();
                closeModal();
            } else {
                isRunning = false;
                hudLabel.innerText = "DURDURULDU";
                hudLabel.style.color = "#fbbf24"; 
            }
        }

        function stopTimer() {
            isRunning = false;
            hudLabel.innerText = "DOLDU";
            hudLabel.style.color = "#ef4444"; 
            modal.classList.add('visible');
        }

        function resetTimerLogic() {
            const total = calculateTotalBalls();
            totalTime = total > 0 ? total : 60;

            const baseCount = 60;
            if (total > baseCount) {
                // Top sayısı arttıkça küçült, ama sıvı olduğu için çok küçültme
                ballRadius = 0.15 * Math.pow(baseCount / total, 1/3);
            } else {
                ballRadius = 0.15;
            }
            ballRadius = Math.max(0.05, Math.min(0.2, ballRadius));

            currentTime = totalTime;
            isRunning = false;
            initializeBalls(totalTime);
            updateTimerHUD(currentTime);
            hudLabel.innerText = "HAZIR";
            hudLabel.style.color = "#0ea5e9"; 
            closeModal();

            hourglassGroup.rotation.z = Math.PI;
            let rotationProgress = 0;
            const rotateInterval = setInterval(() => {
                rotationProgress += 0.05; // Yavaşça çevir
                hourglassGroup.rotation.z -= 0.05;
                if (hourglassGroup.rotation.z <= 0) {
                    hourglassGroup.rotation.z = 0;
                    clearInterval(rotateInterval);
                }
            }, 16);
        }

        startBtn.addEventListener('click', startTimer);
        resetBtn.addEventListener('click', resetTimerLogic);
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>
</body>
</html>

